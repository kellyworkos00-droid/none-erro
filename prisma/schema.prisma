// Prisma Schema for Kelly OS - Bank Statement Reconciliation Module
// PostgreSQL (Supabase) version for production-ready deployment

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
  directUrl = env("DIRECT_URL")
}

// ============================================================================
// USER MANAGEMENT & AUTHENTICATION
// ============================================================================

// UserRole enum values: ADMIN, FINANCE_MANAGER, FINANCE_STAFF, VIEWER

model User {
  id        String   @id @default(cuid())
  email     String   @unique
  password  String   // Hashed with bcrypt
  firstName String
  lastName  String
  role      String   @default("VIEWER")
  isActive  Boolean  @default(true)
  
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  lastLogin DateTime?

  // Relationships
  payments             Payment[]
  reconciliationLogs   ReconciliationLog[]
  ledgerEntries        LedgerEntry[]
  auditLogs            AuditLog[]
  bankTransactions     BankTransaction[]
  posOrders            PosOrder[]
  purchaseOrders       PurchaseOrder[]
  expenses             Expense[]
  supplierBills        SupplierBill[]
  supplierPayments     SupplierPayment[]
  salesQuotes          SalesQuote[]
  salesOrders          SalesOrder[]
  salesDeliveries      SalesDelivery[]
  approvedSalesOrders  SalesOrder[]    @relation("SalesOrderApprovedBy")
  approvedSupplierBills SupplierBill[] @relation("SupplierBillApprovedBy")
  matchedSupplierBills  SupplierBill[] @relation("SupplierBillMatchedBy")
  stockMovements       StockMovement[]
  stockTransfers       StockTransfer[]
  projectsCreated      Project[]
  systemLogs           SystemLog[]
  creditNotesCreated   CreditNote[]   @relation("CreditNoteCreatedBy")
  creditNotesApproved  CreditNote[]   @relation("CreditNoteApprovedBy")
  productReturns       ProductReturn[]
  notifications        Notification[]
  notificationPreference NotificationPreference?
  reportTemplates      ReportTemplate[]

  @@map("users")
}

// ============================================================================
// PROJECT & TENDER MANAGEMENT
// ============================================================================

// ProjectStatus values: PLANNING, IN_PROGRESS, COMPLETED, CANCELLED

model Project {
  id                String   @id @default(cuid())
  name              String
  clientName        String
  tenderReference   String?
  description       String?

  quotedAmount      Float    @default(0)
  estimatedExpenses Float    @default(0)
  actualExpenses    Float    @default(0)
  status            String   @default("PLANNING")

  createdBy         String
  createdAt         DateTime @default(now())
  updatedAt         DateTime @updatedAt

  createdByUser     User       @relation(fields: [createdBy], references: [id], onDelete: Restrict)
  milestones        ProjectMilestone[]
  expenses          ProjectExpense[]

  @@map("projects")
}

model ProjectMilestone {
  id          String   @id @default(cuid())
  projectId   String
  title       String
  description String?
  dueDate     DateTime?
  status      String   @default("PENDING") // PENDING, IN_PROGRESS, COMPLETED, CANCELLED
  priority    String   @default("MEDIUM")  // LOW, MEDIUM, HIGH, CRITICAL
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  project     Project  @relation(fields: [projectId], references: [id], onDelete: Cascade)

  @@index([projectId])
  @@index([status])
  @@map("project_milestones")
}

model ProjectExpense {
  id          String   @id @default(cuid())
  projectId   String
  description String
  category    String
  amount      Float
  date        DateTime @default(now())
  notes       String?
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  project     Project  @relation(fields: [projectId], references: [id], onDelete: Cascade)

  @@index([projectId])
  @@index([category])
  @@map("project_expenses")
}

// ============================================================================
// CUSTOMER MANAGEMENT
// ============================================================================

model Customer {
  id              String   @id @default(cuid())
  customerCode    String   @unique // e.g., "CUST-0001"
  name            String
  email           String?
  phone           String?
  billingAddress  String?
  
  // Financial tracking
  currentBalance  Float  @default(0)
  totalPaid       Float  @default(0)
  totalOutstanding Float @default(0)
  creditLimit     Float?
  
  // Payment metrics
  totalPayments   Int    @default(0)
  averagePaymentAmount Float @default(0)
  lastPaymentDate DateTime?
  daysOverdue     Int    @default(0)
  
  isActive        Boolean  @default(true)
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  // Relationships
  invoices        Invoice[]
  payments        Payment[]
  ledgerEntries   LedgerEntry[]
  posOrders       PosOrder[] @relation("PosOrderCustomer")
  salesQuotes     SalesQuote[]
  salesOrders     SalesOrder[]
  creditNotes     CreditNote[]

  @@index([currentBalance])
  @@index([totalOutstanding])
  @@map("customers")
}

// ============================================================================
// INVOICE MANAGEMENT
// ============================================================================

// InvoiceStatus values: DRAFT, SENT, PARTIALLY_PAID, PAID, OVERDUE, CANCELLED

model Invoice {
  id              String        @id @default(cuid())
  invoiceNumber   String        @unique // e.g., "INV-2024-0001"
  customerId      String
  
  // Financial details
  subtotal        Float
  taxAmount       Float       @default(0)
  totalAmount     Float
  paidAmount      Float       @default(0)
  balanceAmount   Float
  
  // Status tracking
  status          String @default("DRAFT")
  issueDate       DateTime
  dueDate         DateTime
  paidDate        DateTime?
  
  // Payment tracking
  lastPaymentDate DateTime?
  paymentCount    Int         @default(0)    // Total number of payments
  partialPaymentCount Int      @default(0)   // Number of partial payments
  
  // Metadata
  description     String?
  notes           String?
  createdAt       DateTime      @default(now())
  updatedAt       DateTime      @updatedAt

  // Relationships
  customer        Customer      @relation(fields: [customerId], references: [id], onDelete: Restrict)
  posOrders       PosOrder[]    @relation("PosOrderInvoice")
  payments        Payment[]
  ledgerEntries   LedgerEntry[]
  salesOrder      SalesOrder? @relation("SalesOrderInvoice")
  creditNotes     CreditNote[]

  @@index([status])
  @@index([paidAmount])
  @@map("invoices")
}

// ============================================================================
// CREDIT NOTES
// ============================================================================

// CreditNoteStatus values: DRAFT, PENDING, APPROVED, APPLIED, CANCELLED
// CreditNoteType values: REFUND, RETURN, ADJUSTMENT, DISCOUNT, DAMAGED, ERROR_CORRECTION

model CreditNote {
  id                String   @id @default(cuid())
  creditNoteNumber  String   @unique // e.g., "CN-2024-0001"
  customerId        String
  invoiceId         String?  // Optional - can be standalone
  
  // Financial details
  subtotal          Float
  taxAmount         Float    @default(0)
  totalAmount       Float
  appliedAmount     Float    @default(0)  // Amount applied to invoices
  remainingAmount   Float                 // Available credit
  
  // Credit note details
  creditNoteType    String   @default("REFUND") // REFUND, RETURN, ADJUSTMENT, etc.
  reason            String                     // Reason for credit note
  status            String   @default("DRAFT")  // DRAFT, PENDING, APPROVED, APPLIED, CANCELLED
  
  // Important dates
  issueDate         DateTime
  approvedDate      DateTime?
  appliedDate       DateTime?
  
  // Reference to product return if applicable
  referenceType     String?  // e.g., "PRODUCT_RETURN", "SALES_ORDER"
  referenceId       String?  // ID of the referenced entity
  
  // Metadata
  notes             String?
  internalNotes     String?
  createdBy         String
  approvedBy        String?
  createdAt         DateTime @default(now())
  updatedAt         DateTime @updatedAt

  // Relationships
  customer          Customer @relation(fields: [customerId], references: [id], onDelete: Restrict)
  invoice           Invoice? @relation(fields: [invoiceId], references: [id], onDelete: Restrict)
  createdByUser     User     @relation("CreditNoteCreatedBy", fields: [createdBy], references: [id], onDelete: Restrict)
  approvedByUser    User?    @relation("CreditNoteApprovedBy", fields: [approvedBy], references: [id], onDelete: Restrict)
  items             CreditNoteItem[]

  @@index([customerId])
  @@index([invoiceId])
  @@index([status])
  @@index([issueDate])
  @@map("credit_notes")
}

model CreditNoteItem {
  id              String     @id @default(cuid())
  creditNoteId    String
  
  // Item details
  description     String
  quantity        Float
  unitPrice       Float
  taxRate         Float      @default(0)
  taxAmount       Float      @default(0)
  totalAmount     Float
  
  // Optional product reference
  productId       String?
  sku             String?
  
  // Metadata
  notes           String?

  // Relationships
  creditNote      CreditNote @relation(fields: [creditNoteId], references: [id], onDelete: Cascade)

  @@index([creditNoteId])
  @@map("credit_note_items")
}

// ============================================================================
// PRODUCT RETURNS
// ============================================================================

// ProductReturnStatus values: PENDING, APPROVED, PROCESSING, COMPLETED, REJECTED
// ProductReturnType values: CUSTOMER_RETURN, SUPPLIER_RETURN, DAMAGED, WARRANTY
// ItemCondition values: GOOD, DAMAGED, DEFECTIVE, EXPIRED

model ProductReturn {
  id              String   @id @default(cuid())
  returnNumber    String   @unique // e.g., "RET-1234567890-ABCD"
  
  returnType      String   @default("CUSTOMER_RETURN") // CUSTOMER_RETURN, SUPPLIER_RETURN, DAMAGED, WARRANTY
  referenceType   String?  // e.g., "SALES_ORDER", "INVOICE"
  referenceId     String?  // ID of referenced entity
  
  customerId      String?
  supplierId      String?
  
  reason          String
  status          String   @default("PENDING") // PENDING, APPROVED, PROCESSING, COMPLETED, REJECTED
  
  totalAmount     Float
  refundAmount    Float
  restockFee      Float    @default(0)
  
  returnDate      DateTime @default(now())
  approvedDate    DateTime?
  completedDate   DateTime?
  
  notes           String?
  createdBy       String
  approvedBy      String?
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  // Relationships
  createdByUser   User     @relation(fields: [createdBy], references: [id], onDelete: Restrict)
  items           ProductReturnItem[]

  @@index([returnType])
  @@index([status])
  @@index([returnDate])
  @@map("product_returns")
}

model ProductReturnItem {
  id          String        @id @default(cuid())
  returnId    String
  productId   String
  locationId  String?
  
  quantity    Float
  unitPrice   Float
  totalPrice  Float
  
  condition   String        @default("GOOD") // GOOD, DAMAGED, DEFECTIVE, EXPIRED
  restockable Boolean       @default(true)
  notes       String?

  // Relationships
  productReturn ProductReturn @relation(fields: [returnId], references: [id], onDelete: Cascade)
  product       Product       @relation(fields: [productId], references: [id], onDelete: Restrict)

  @@index([returnId])
  @@index([productId])
  @@map("product_return_items")
}

// ============================================================================
// BANK TRANSACTIONS (Raw Imported Data)
// ============================================================================

// TransactionStatus values: PENDING, MATCHED, UNMATCHED, PARTIALLY_MATCHED, REJECTED

model BankTransaction {
  id                String            @id @default(cuid())
  
  // Unique identifier from bank (prevents duplicate imports)
  bankTransactionId String            @unique
  
  // Transaction details
  transactionDate   DateTime
  valueDate         DateTime?
  amount            Float
  currency          String            @default("KES")
  
  // Bank statement fields
  reference         String            // Customer reference / description
  debitAccount      String?
  creditAccount     String?
  balance           Float?
  
  // Reconciliation status
  status            String @default("PENDING")
  matchedAt         DateTime?
  matchedBy         String?
  
  // Source tracking
  statementFileName String
  statementUploadId String
  rowNumber         Int
  
  // Audit
  importedAt        DateTime          @default(now())
  importedBy        String
  
  // Relationships
  importedByUser    User              @relation(fields: [importedBy], references: [id], onDelete: Restrict)
  payments          Payment[]
  reconciliationLog ReconciliationLog?

  @@map("bank_transactions")
}

// ============================================================================
// PAYMENTS (Links customers to bank transactions)
// ============================================================================

// PaymentStatus values: PENDING, CONFIRMED, RECONCILED, REVERSED

model Payment {
  id                  String        @id @default(cuid())
  paymentNumber       String        @unique @default(cuid())
  
  // Link to customer and invoice
  customerId          String
  invoiceId           String?
  
  // Link to bank transaction
  bankTransactionId   String?       @unique
  
  // Payment details
  amount              Float
  paymentDate         DateTime
  paymentMethod       String        @default("BANK_TRANSFER")
  reference           String
  
  // Status
  status              String @default("PENDING")
  
  // Reconciliation tracking
  isReconciled        Boolean       @default(false)
  reconciledAt        DateTime?
  reconciledBy        String?
  
  // New fields for enhanced payment tracking
  requestId           String?       // UUID for distributed tracing
  processingTime      Int?          // milliseconds
  metadata            String?       // JSON with payment-specific data
  failureReason       String?       // If payment failed
  retryCount          Int           @default(0)
  lastRetryAt         DateTime?
  
  // Metadata
  notes               String?
  createdAt           DateTime      @default(now())
  updatedAt           DateTime      @updatedAt

  // Relationships
  customer            Customer           @relation(fields: [customerId], references: [id], onDelete: Restrict)
  invoice             Invoice?           @relation(fields: [invoiceId], references: [id], onDelete: Restrict)
  bankTransaction     BankTransaction?   @relation(fields: [bankTransactionId], references: [id], onDelete: Restrict)
  reconciledByUser    User?              @relation(fields: [reconciledBy], references: [id], onDelete: Restrict)
  ledgerEntries       LedgerEntry[]

  @@index([requestId])
  @@index([retryCount])
  @@map("payments")
}

// ============================================================================
// DOUBLE-ENTRY LEDGER SYSTEM
// ============================================================================

// LedgerEntryType values: DEBIT, CREDIT
// AccountType values: ASSET, LIABILITY, EQUITY, REVENUE, EXPENSE

model Account {
  id          String      @id @default(cuid())
  accountCode String      @unique // e.g., "1010" for Cash, "1200" for AR
  accountName String
  accountType String
  description String?
  
  // Financial tracking
  currentBalance Float  @default(0)
  
  isActive    Boolean     @default(true)
  createdAt   DateTime    @default(now())
  updatedAt   DateTime    @updatedAt

  // Relationships
  ledgerEntries LedgerEntry[]

  @@map("accounts")
}

model LedgerEntry {
  id              String          @id @default(cuid())
  
  // Linking
  accountId       String
  transactionId   String          // Groups debit/credit pairs
  
  // Entry details
  entryType       String
  amount          Float
  entryDate       DateTime
  description     String
  
  // Reference linking (Optional - for traceability)
  customerId      String?
  invoiceId       String?
  paymentId       String?
  
  // Metadata (IMMUTABLE after creation)
  isReversed      Boolean         @default(false)
  reversalEntryId String?         @unique
  
  // Audit trail
  createdBy       String
  createdAt       DateTime        @default(now())
  
  // Relationships
  account         Account         @relation(fields: [accountId], references: [id], onDelete: Restrict)
  customer        Customer?       @relation(fields: [customerId], references: [id], onDelete: Restrict)
  invoice         Invoice?        @relation(fields: [invoiceId], references: [id], onDelete: Restrict)
  payment         Payment?        @relation(fields: [paymentId], references: [id], onDelete: Restrict)
  createdByUser   User            @relation(fields: [createdBy], references: [id], onDelete: Restrict)
  reversalEntry   LedgerEntry?    @relation("Reversal", fields: [reversalEntryId], references: [id], onDelete: NoAction, onUpdate: NoAction)
  reversedBy      LedgerEntry?    @relation("Reversal")

  @@map("ledger_entries")
}

// ============================================================================
// RECONCILIATION LOGS (Audit Trail)
// ============================================================================

// ReconciliationAction values: AUTO_MATCHED, MANUAL_MATCHED, UNMATCHED, REJECTED, REVERSED

model ReconciliationLog {
  id                String                @id @default(cuid())
  
  bankTransactionId String                @unique
  action            String
  
  // Match details
  matchedCustomerId String?
  matchedInvoiceId  String?
  matchedAmount     Float?
  
  // Reasoning
  reason            String?
  notes             String?
  
  // Audit
  performedBy       String
  performedAt       DateTime              @default(now())

  // Relationships
  bankTransaction   BankTransaction       @relation(fields: [bankTransactionId], references: [id], onDelete: Cascade)
  performedByUser   User                  @relation(fields: [performedBy], references: [id], onDelete: Restrict)

  @@map("reconciliation_logs")
}

// ============================================================================
// AUDIT LOGS (System-wide activity tracking)
// ============================================================================

// AuditAction values: LOGIN, LOGOUT, UPLOAD_STATEMENT, RECONCILE_PAYMENT, CREATE_CUSTOMER, UPDATE_CUSTOMER, CREATE_INVOICE, UPDATE_INVOICE, MANUAL_ADJUSTMENT,REVERSE_PAYMENT, DELETE_RECORD, EXPORT_DATA

model AuditLog {
  id          String      @id @default(cuid())
  
  userId      String
  action      String
  entityType  String?     // e.g., "Customer", "Invoice", "Payment"
  entityId    String?
  
  // Details
  description String
  ipAddress   String?
  userAgent   String?
  metadata    String?       // Additional context as JSON string
  
  createdAt   DateTime    @default(now())

  // Relationships
  user        User        @relation(fields: [userId], references: [id], onDelete: Restrict)

  @@map("audit_logs")
}

// ============================================================================
// POS SYSTEM (Point of Sale)
// ============================================================================

// ProductStatus values: ACTIVE, DISCONTINUED, OUT_OF_STOCK

model Product {
  id              String      @id @default(cuid())
  sku             String      @unique // Auto-generated SKU (e.g., "SKU-1234567890")
  name            String
  description     String?
  
  // Pricing
  price           Float
  cost            Float?
  
  // Inventory
  quantity        Int         @default(0)
  reorderLevel    Int         @default(10)
  unit            String      @default("UNIT")
  
  // Image
  imageUrl        String?     // URL to product image
  
  // Status
  status          String      @default("ACTIVE")
  
  // Metadata
  category        String?
  createdAt       DateTime    @default(now())
  updatedAt       DateTime    @updatedAt

  // Relationships
  posOrderItems   PosOrderItem[]
  purchaseOrderItems PurchaseOrderItem[]
  salesQuoteItems SalesQuoteItem[]
  salesOrderItems SalesOrderItem[]
  salesDeliveryItems SalesDeliveryItem[]
  stockLevels     StockLevel[]
  stockMovements  StockMovement[]
  stockTransferItems StockTransferItem[]
  productReturnItems ProductReturnItem[]

  @@map("products")
}

// OrderStatus values: DRAFT, COMPLETED, CANCELLED, REFUNDED

model PosOrder {
  id              String        @id @default(cuid())
  orderNumber     String        @unique @default(cuid())
  
  // Customer reference
  customerId      String?
  invoiceId       String?
  
  // Order totals
  subtotal        Float         @default(0)
  tax             Float         @default(0)
  discount        Float         @default(0)
  totalAmount     Float         @default(0)
  
  // Payment
  amountPaid      Float         @default(0)
  paymentMethod   String?       // CASH, CARD, CHEQUE, etc.
  paymentStatus   String        @default("PENDING")
  
  // Status
  status          String        @default("DRAFT")
  
  // User tracking
  createdBy       String
  
  // Timestamps
  orderDate       DateTime      @default(now())
  completedAt     DateTime?
  createdAt       DateTime      @default(now())
  updatedAt       DateTime      @updatedAt

  // Relationships
  customer        Customer?     @relation("PosOrderCustomer", fields: [customerId], references: [id], onDelete: SetNull)
  invoice         Invoice?      @relation("PosOrderInvoice", fields: [invoiceId], references: [id], onDelete: SetNull)
  createdByUser   User          @relation(fields: [createdBy], references: [id], onDelete: Restrict)
  orderItems      PosOrderItem[]

  @@map("pos_orders")
}

model PosOrderItem {
  id              String        @id @default(cuid())
  posOrderId      String
  productId       String
  
  // Item details
  quantity        Int
  unitPrice       Float
  discount        Float         @default(0)
  totalPrice      Float
  
  // Metadata
  notes           String?
  createdAt       DateTime      @default(now())

  // Relationships
  posOrder        PosOrder      @relation(fields: [posOrderId], references: [id], onDelete: Cascade)
  product         Product       @relation(fields: [productId], references: [id], onDelete: Restrict)

  @@map("pos_order_items")
}

// ============================================================================
// ERP: SUPPLIERS & PURCHASING
// ============================================================================

model Supplier {
  id            String        @id @default(cuid())
  supplierCode  String        @unique
  name          String
  email         String?
  phone         String?
  address       String?
  isActive      Boolean       @default(true)
  createdAt     DateTime      @default(now())
  updatedAt     DateTime      @updatedAt

  // Relationships
  purchaseOrders PurchaseOrder[]
  bills         SupplierBill[]
  payments      SupplierPayment[]

  @@map("suppliers")
}

// PurchaseOrderStatus values: DRAFT, APPROVED, SENT, RECEIVED, CANCELLED

model PurchaseOrder {
  id           String        @id @default(cuid())
  orderNumber  String        @unique
  supplierId   String

  // Totals
  subtotal     Float         @default(0)
  tax          Float         @default(0)
  totalAmount  Float         @default(0)

  // Status
  status       String        @default("DRAFT")
  expectedDate DateTime?
  notes        String?

  // Audit
  createdBy    String
  createdAt    DateTime      @default(now())
  updatedAt    DateTime      @updatedAt

  // Relationships
  supplier     Supplier      @relation(fields: [supplierId], references: [id], onDelete: Restrict)
  createdByUser User          @relation(fields: [createdBy], references: [id], onDelete: Restrict)
  items        PurchaseOrderItem[]
  bills        SupplierBill[]

  @@map("purchase_orders")
}

model PurchaseOrderItem {
  id              String        @id @default(cuid())
  purchaseOrderId String
  productId       String
  quantity        Int
  unitCost        Float
  totalCost       Float
  createdAt       DateTime      @default(now())

  // Relationships
  purchaseOrder   PurchaseOrder @relation(fields: [purchaseOrderId], references: [id], onDelete: Cascade)
  product         Product       @relation(fields: [productId], references: [id], onDelete: Restrict)

  @@map("purchase_order_items")
}

// ============================================================================
// ERP: SUPPLIER BILLS & PAYMENTS
// ============================================================================

// SupplierBillStatus values: DRAFT, OPEN, PARTIALLY_PAID, PAID, OVERDUE, CANCELLED

model SupplierBill {
  id            String      @id @default(cuid())
  billNumber    String      @unique
  supplierId    String
  reference     String?
  issueDate     DateTime
  dueDate       DateTime

  // Amounts
  totalAmount   Float
  paidAmount    Float       @default(0)
  balanceAmount Float

  status        String      @default("OPEN")
  approvalStatus String     @default("NOT_SUBMITTED")
  approvedBy    String?
  approvedAt    DateTime?
  submittedAt   DateTime?
  purchaseOrderId String?
  matchedAt     DateTime?
  matchedBy     String?
  notes         String?

  // Audit
  createdBy     String
  createdAt     DateTime    @default(now())
  updatedAt     DateTime    @updatedAt

  // Relationships
  supplier      Supplier    @relation(fields: [supplierId], references: [id], onDelete: Restrict)
  createdByUser User        @relation(fields: [createdBy], references: [id], onDelete: Restrict)
  approvedByUser User?      @relation("SupplierBillApprovedBy", fields: [approvedBy], references: [id], onDelete: SetNull)
  matchedByUser  User?      @relation("SupplierBillMatchedBy", fields: [matchedBy], references: [id], onDelete: SetNull)
  purchaseOrder PurchaseOrder? @relation(fields: [purchaseOrderId], references: [id], onDelete: SetNull)
  payments      SupplierPayment[]

  @@map("supplier_bills")
}

model SupplierPayment {
  id            String      @id @default(cuid())
  paymentNumber String      @unique
  supplierId    String
  billId        String
  amount        Float
  paymentDate   DateTime
  paymentMethod String?
  reference     String?
  notes         String?

  // Audit
  createdBy     String
  createdAt     DateTime    @default(now())

  // Relationships
  supplier      Supplier    @relation(fields: [supplierId], references: [id], onDelete: Restrict)
  bill          SupplierBill @relation(fields: [billId], references: [id], onDelete: Cascade)
  createdByUser User        @relation(fields: [createdBy], references: [id], onDelete: Restrict)

  @@map("supplier_payments")
}

// ============================================================================
// ERP: SALES QUOTES, ORDERS, DELIVERIES
// ============================================================================

// SalesQuoteStatus values: DRAFT, SENT, ACCEPTED, DECLINED, EXPIRED

model SalesQuote {
  id            String      @id @default(cuid())
  quoteNumber   String      @unique
  customerId    String
  status        String      @default("DRAFT")
  subtotal      Float       @default(0)
  tax           Float       @default(0)
  totalAmount   Float       @default(0)
  validUntil    DateTime?
  notes         String?

  createdBy     String
  createdAt     DateTime    @default(now())
  updatedAt     DateTime    @updatedAt

  customer      Customer    @relation(fields: [customerId], references: [id], onDelete: Restrict)
  createdByUser User        @relation(fields: [createdBy], references: [id], onDelete: Restrict)
  items         SalesQuoteItem[]
  salesOrder    SalesOrder?

  @@map("sales_quotes")
}

model SalesQuoteItem {
  id           String      @id @default(cuid())
  salesQuoteId String
  productId    String
  quantity     Int
  unitPrice    Float
  discount     Float       @default(0)
  totalPrice   Float
  createdAt    DateTime    @default(now())

  salesQuote   SalesQuote  @relation(fields: [salesQuoteId], references: [id], onDelete: Cascade)
  product      Product     @relation(fields: [productId], references: [id], onDelete: Restrict)

  @@map("sales_quote_items")
}

// SalesOrderStatus values: DRAFT, PENDING_APPROVAL, APPROVED, DELIVERED, INVOICED, COMPLETED, CANCELLED
// SalesApprovalStatus values: NOT_SUBMITTED, PENDING, APPROVED, REJECTED

model SalesOrder {
  id            String      @id @default(cuid())
  orderNumber   String      @unique
  customerId    String
  quoteId       String?     @unique
  invoiceId     String?     @unique

  status        String      @default("DRAFT")
  approvalStatus String     @default("NOT_SUBMITTED")
  approvedBy    String?
  approvedAt    DateTime?
  submittedAt   DateTime?
  deliveredAt   DateTime?
  notes         String?

  subtotal      Float       @default(0)
  tax           Float       @default(0)
  totalAmount   Float       @default(0)

  createdBy     String
  createdAt     DateTime    @default(now())
  updatedAt     DateTime    @updatedAt

  customer      Customer    @relation(fields: [customerId], references: [id], onDelete: Restrict)
  createdByUser User        @relation(fields: [createdBy], references: [id], onDelete: Restrict)
  approvedByUser User?      @relation("SalesOrderApprovedBy", fields: [approvedBy], references: [id], onDelete: SetNull)
  quote         SalesQuote? @relation(fields: [quoteId], references: [id], onDelete: SetNull)
  invoice       Invoice?    @relation("SalesOrderInvoice", fields: [invoiceId], references: [id], onDelete: SetNull)
  items         SalesOrderItem[]
  deliveries    SalesDelivery[]

  @@map("sales_orders")
}

model SalesOrderItem {
  id           String      @id @default(cuid())
  salesOrderId String
  productId    String
  quantity     Int
  unitPrice    Float
  discount     Float       @default(0)
  totalPrice   Float
  createdAt    DateTime    @default(now())

  salesOrder   SalesOrder  @relation(fields: [salesOrderId], references: [id], onDelete: Cascade)
  product      Product     @relation(fields: [productId], references: [id], onDelete: Restrict)

  @@map("sales_order_items")
}

// SalesDeliveryStatus values: PENDING, DISPATCHED, DELIVERED, CANCELLED

model SalesDelivery {
  id            String      @id @default(cuid())
  deliveryNumber String     @unique
  salesOrderId  String
  status        String      @default("PENDING")
  dispatchedAt  DateTime?
  deliveredAt   DateTime?
  createdBy     String
  createdAt     DateTime    @default(now())
  updatedAt     DateTime    @updatedAt

  salesOrder    SalesOrder  @relation(fields: [salesOrderId], references: [id], onDelete: Cascade)
  createdByUser User        @relation(fields: [createdBy], references: [id], onDelete: Restrict)
  items         SalesDeliveryItem[]

  @@map("sales_deliveries")
}

model SalesDeliveryItem {
  id             String       @id @default(cuid())
  salesDeliveryId String
  productId      String
  quantity       Int
  createdAt      DateTime     @default(now())

  salesDelivery  SalesDelivery @relation(fields: [salesDeliveryId], references: [id], onDelete: Cascade)
  product        Product      @relation(fields: [productId], references: [id], onDelete: Restrict)

  @@map("sales_delivery_items")
}

// ============================================================================
// ERP: WAREHOUSES & STOCK
// ============================================================================

model Warehouse {
  id          String             @id @default(cuid())
  code        String             @unique
  name        String
  address     String?
  isActive    Boolean            @default(true)
  createdAt   DateTime           @default(now())
  updatedAt   DateTime           @updatedAt

  locations   WarehouseLocation[]
  stockLevels StockLevel[]
  movements   StockMovement[]

  @@map("warehouses")
}

model WarehouseLocation {
  id          String        @id @default(cuid())
  warehouseId String
  code        String
  name        String
  isActive    Boolean       @default(true)
  createdAt   DateTime      @default(now())
  updatedAt   DateTime      @updatedAt

  warehouse   Warehouse     @relation(fields: [warehouseId], references: [id], onDelete: Cascade)
  stockLevels StockLevel[]
  movements   StockMovement[]
  transfersFrom StockTransfer[] @relation("TransferFromLocation")
  transfersTo   StockTransfer[] @relation("TransferToLocation")

  @@unique([warehouseId, code])
  @@map("warehouse_locations")
}

model StockLevel {
  id          String            @id @default(cuid())
  productId   String
  warehouseId String
  locationId  String
  quantity    Int               @default(0)
  updatedAt   DateTime          @updatedAt

  product     Product           @relation(fields: [productId], references: [id], onDelete: Cascade)
  warehouse   Warehouse         @relation(fields: [warehouseId], references: [id], onDelete: Cascade)
  location    WarehouseLocation @relation(fields: [locationId], references: [id], onDelete: Cascade)

  @@unique([productId, locationId])
  @@map("stock_levels")
}

model StockMovement {
  id          String            @id @default(cuid())
  productId   String
  warehouseId String
  locationId  String
  quantity    Int
  movementType String
  referenceType String?
  referenceId String?
  notes       String?
  createdBy   String
  createdAt   DateTime          @default(now())

  product     Product           @relation(fields: [productId], references: [id], onDelete: Cascade)
  warehouse   Warehouse         @relation(fields: [warehouseId], references: [id], onDelete: Cascade)
  location    WarehouseLocation @relation(fields: [locationId], references: [id], onDelete: Cascade)
  createdByUser User            @relation(fields: [createdBy], references: [id], onDelete: Restrict)

  @@index([productId])
  @@index([warehouseId])
  @@index([locationId])
  @@map("stock_movements")
}

model StockTransfer {
  id            String            @id @default(cuid())
  transferNumber String           @unique
  fromLocationId String
  toLocationId   String
  status         String           @default("DRAFT")
  createdBy      String
  createdAt      DateTime         @default(now())
  completedAt    DateTime?

  fromLocation   WarehouseLocation @relation("TransferFromLocation", fields: [fromLocationId], references: [id], onDelete: Restrict)
  toLocation     WarehouseLocation @relation("TransferToLocation", fields: [toLocationId], references: [id], onDelete: Restrict)
  createdByUser  User              @relation(fields: [createdBy], references: [id], onDelete: Restrict)
  items          StockTransferItem[]

  @@map("stock_transfers")
}

model StockTransferItem {
  id            String        @id @default(cuid())
  transferId    String
  productId     String
  quantity      Int

  transfer      StockTransfer @relation(fields: [transferId], references: [id], onDelete: Cascade)
  product       Product       @relation(fields: [productId], references: [id], onDelete: Restrict)

  @@map("stock_transfer_items")
}

// ============================================================================
// ERP: EXPENSE CATEGORIES & EXPENSES
// ============================================================================

model ExpenseCategory {
  id                    String    @id @default(cuid())
  name                  String    @unique
  monthlyBudget         Float     @default(0)
  alertThresholdPercent Float     @default(80)
  isActive              Boolean   @default(true)
  createdAt             DateTime  @default(now())
  updatedAt             DateTime  @updatedAt

  // Relationships
  expenses              Expense[]

  @@map("expense_categories")
}

model Expense {
  id            String        @id @default(cuid())
  expenseNumber String        @unique
  category      String
  categoryId    String?
  amount        Float
  description   String?
  expenseDate   DateTime
  paymentMethod String?
  vendor        String?
  reference     String?

  // Audit
  createdBy     String
  createdAt     DateTime      @default(now())
  updatedAt     DateTime      @updatedAt

  // Relationships
  createdByUser User          @relation(fields: [createdBy], references: [id], onDelete: Restrict)
  categoryRef   ExpenseCategory? @relation(fields: [categoryId], references: [id], onDelete: SetNull)

  @@map("expenses")
}

// ============================================================================
// LOGGING & MONITORING SYSTEM
// ============================================================================

// LogLevel values: DEBUG, INFO, WARN, ERROR, CRITICAL
// LogCategory values: PAYMENT, INVOICE, AUTH, SECURITY, VALIDATION, DATABASE, EXTERNAL_API, PERFORMANCE, SYSTEM, USER

model SystemLog {
  id          String      @id @default(cuid())
  
  // Log details
  message     String
  level       String      // DEBUG, INFO, WARN, ERROR, CRITICAL
  category    String      // PAYMENT, INVOICE, AUTH, SECURITY, etc.
  
  // Context
  userId      String?
  requestId   String?
  ipAddress   String?
  
  // Metadata
  duration    Int?        // milliseconds
  error       String?     // Error message if applicable
  metadata    String?     // JSON string with additional data
  
  // Tracking
  createdAt   DateTime    @default(now())
  expiresAt   DateTime?   // For log retention policy
  
  // Index for common queries
  user        User?       @relation(fields: [userId], references: [id], onDelete: SetNull)
  
  @@index([level])
  @@index([category])
  @@index([userId])
  @@index([requestId])
  @@index([createdAt])
  @@map("system_logs")
}

// API Metrics - Track endpoint performance
model ApiMetric {
  id            String      @id @default(cuid())
  
  endpoint      String      // e.g., "/api/payments"
  method        String      // GET, POST, PUT, DELETE
  statusCode    Int
  responseTime  Int         // milliseconds
  
  // Aggregation
  timestamp     DateTime    @default(now())
  
  @@index([endpoint])
  @@index([method])
  @@index([timestamp])
  @@map("api_metrics")
}

// Database Query Metrics - Track query performance
model QueryMetric {
  id          String      @id @default(cuid())
  
  query       String      // Query description
  duration    Int         // milliseconds
  hasError    Boolean     @default(false)
  errorMessage String?
  
  // Aggregation
  timestamp   DateTime    @default(now())
  
  @@index([duration])
  @@index([hasError])
  @@index([timestamp])
  @@map("query_metrics")
}

// ============================================================================
// PAYMENT METHOD ENUM & METADATA
// ============================================================================

// PaymentMethodType values: BANK_TRANSFER, CARD, MOBILE_MONEY, DIGITAL_WALLET, CRYPTO, CASH, CHEQUE, DIRECT_DEBIT, BUY_NOW_PAY_LATER, INVOICE_FINANCING, CRYPTOCURRENCY, ACH_TRANSFER, WIRE_TRANSFER, PAYPAL, STRIPE

model PaymentMethodConfig {
  id              String      @id @default(cuid())
  
  methodName      String      @unique  // e.g., "BANK_TRANSFER"
  displayName     String      // e.g., "Bank Transfer"
  icon            String?     // Icon/logo URL
  category        String      // TRADITIONAL, MOBILE, DIGITAL, CRYPTO
  processingTime  Int         // minutes
  isActive        Boolean     @default(true)
  requiresReference Boolean   @default(true)
  
  // Metadata
  metadata        String?     // JSON config
  createdAt       DateTime    @default(now())
  updatedAt       DateTime    @updatedAt
  
  @@map("payment_method_configs")
}

// ============================================================================
// HUMAN RESOURCES & PAYROLL MANAGEMENT
// ============================================================================

model Department {
  id          String      @id @default(cuid())
  name        String      @unique
  description String?
  managerId   String?
  isActive    Boolean     @default(true)
  
  createdAt   DateTime    @default(now())
  updatedAt   DateTime    @updatedAt
  
  manager     Employee?   @relation("DepartmentManager", fields: [managerId], references: [id], onDelete: SetNull)
  employees   Employee[]
  
  @@map("departments")
}

model Employee {
  id              String      @id @default(cuid())
  employeeNumber  String      @unique
  
  // Personal Information
  firstName       String
  lastName        String
  email           String      @unique
  phone           String?
  dateOfBirth     DateTime?
  gender          String?     // MALE, FEMALE, OTHER
  address         String?
  city            String?
  country         String      @default("Kenya")
  
  // Employment Information
  departmentId    String?
  position        String
  employmentType  String      @default("FULL_TIME") // FULL_TIME, PART_TIME, CONTRACT, INTERN
  hireDate        DateTime    @default(now())
  terminationDate DateTime?
  employmentStatus String     @default("ACTIVE") // ACTIVE, ON_LEAVE, SUSPENDED, TERMINATED
  
  // Compensation
  basicSalary     Float       @default(0)
  currency        String      @default("KES")
  paymentFrequency String     @default("MONTHLY") // MONTHLY, WEEKLY, BIWEEKLY
  bankName        String?
  bankAccount     String?
  taxId           String?     // KRA PIN
  nhifNumber      String?
  nssfNumber      String?
  
  // System
  isActive        Boolean     @default(true)
  createdAt       DateTime    @default(now())
  updatedAt       DateTime    @updatedAt
  
  // Relationships
  department      Department? @relation(fields: [departmentId], references: [id], onDelete: SetNull)
  departmentsManagedBy Department[] @relation("DepartmentManager")
  payrolls        Payroll[]
  leaves          Leave[]
  attendances     Attendance[]
  
  @@index([employeeNumber])
  @@index([email])
  @@index([departmentId])
  @@index([employmentStatus])
  @@map("employees")
}

model Payroll {
  id              String      @id @default(cuid())
  
  employeeId      String
  month           Int         // 1-12
  year            Int
  
  // Earnings
  basicSalary     Float
  allowances      Float       @default(0)
  bonuses         Float       @default(0)
  overtime        Float       @default(0)
  grossPay        Float
  
  // Deductions
  taxAmount       Float       @default(0)
  nhifAmount      Float       @default(0)
  nssfAmount      Float       @default(0)
  otherDeductions Float       @default(0)
  totalDeductions Float
  
  // Net Pay
  netPay          Float
  
  // Payment Info
  paymentDate     DateTime?
  paymentMethod   String?
  paymentReference String?
  status          String      @default("DRAFT") // DRAFT, PROCESSED, PAID, CANCELLED
  
  // Metadata
  notes           String?
  processingDate  DateTime?
  processedBy     String?
  
  createdAt       DateTime    @default(now())
  updatedAt       DateTime    @updatedAt
  
  employee        Employee    @relation(fields: [employeeId], references: [id], onDelete: Cascade)
  deductions      PayrollDeduction[]
  
  @@unique([employeeId, month, year])
  @@index([employeeId])
  @@index([month, year])
  @@index([status])
  @@map("payrolls")
}

model PayrollDeduction {
  id              String      @id @default(cuid())
  
  payrollId       String
  deductionType   String      // TAX, NHIF, NSSF, LOAN, ADVANCE, OTHER
  description     String
  amount          Float
  
  createdAt       DateTime    @default(now())
  
  payroll         Payroll     @relation(fields: [payrollId], references: [id], onDelete: Cascade)
  
  @@index([payrollId])
  @@map("payroll_deductions")
}

model Leave {
  id              String      @id @default(cuid())
  
  employeeId      String
  leaveType       String      // ANNUAL, SICK, MATERNITY, PATERNITY, UNPAID, OTHER
  startDate       DateTime
  endDate         DateTime
  daysRequested   Int
  
  reason          String
  status          String      @default("PENDING") // PENDING, APPROVED, REJECTED, CANCELLED
  
  approvedBy      String?
  approvedDate    DateTime?
  rejectionReason String?
  
  createdAt       DateTime    @default(now())
  updatedAt       DateTime    @updatedAt
  
  employee        Employee    @relation(fields: [employeeId], references: [id], onDelete: Cascade)
  
  @@index([employeeId])
  @@index([status])
  @@index([startDate, endDate])
  @@map("leaves")
}

model Attendance {
  id              String      @id @default(cuid())
  
  employeeId      String
  date            DateTime    @db.Date
  checkIn         DateTime?
  checkOut        DateTime?
  hoursWorked     Float?
  status          String      @default("PRESENT") // PRESENT, ABSENT, LATE, HALF_DAY, ON_LEAVE
  
  notes           String?
  
  createdAt       DateTime    @default(now())
  updatedAt       DateTime    @updatedAt
  
  employee        Employee    @relation(fields: [employeeId], references: [id], onDelete: Cascade)
  
  @@unique([employeeId, date])
  @@index([employeeId])
  @@index([date])
  @@map("attendances")
}

// ============================================================================
// NOTIFICATIONS & ALERTS SYSTEM
// ============================================================================

model Notification {
  id              String   @id @default(cuid())
  userId          String
  type            String   // RECONCILIATION_COMPLETE, PAYMENT_REMINDER, APPROVAL_REQUIRED, EXCEPTION_ALERT, etc.
  title           String
  message         String
  severity        String   @default("INFO") // INFO, WARNING, ERROR, CRITICAL
  category        String? // reconciliation, payment, approval, matching, etc.
  
  // Related entity references
  relatedEntityId String?
  relatedEntityType String? // RECONCILIATION, PAYMENT, INVOICE, BANK_TRANSACTION, etc.
  
  // Delivery status
  isRead          Boolean  @default(false)
  readAt          DateTime?
  isEmailed       Boolean  @default(false)
  emailedAt       DateTime?
  
  // Metadata
  metadata        Json?    // Store any additional data (amounts, references, etc.)
  actionUrl       String?  // URL to navigate to for this notification
  
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt
  expiresAt       DateTime? // Optional expiration for temporary notifications

  user            User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([isRead])
  @@index([type])
  @@index([severity])
  @@index([createdAt])
  @@index([userId, isRead])
  @@map("notifications")
}

model AlertRule {
  id              String   @id @default(cuid())
  name            String
  description     String?
  enabled         Boolean  @default(true)
  
  // Trigger configuration
  eventType       String   // UNMATCHED_TRANSACTION, FAILED_MATCH, HIGH_VALUE_PAYMENT, OVERDUE_INVOICE, etc.
  triggerCondition Json    // JSON conditions like { "amount": { "gt": 10000 }, "status": "FAILED" }
  priority        String   @default("MEDIUM") // LOW, MEDIUM, HIGH, CRITICAL
  
  // Actions
  notifyUsers     Boolean  @default(true)
  notifyEmail     Boolean  @default(false)
  emailRecipients String? // Comma-separated emails
  webhookUrl      String?  // Optional webhook for external integrations
  
  // Frequency control
  cooldownMinutes Int    @default(0) // Prevent alert spam
  maxAlertsPerDay Int    @default(100)
  
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  alertInstances  AlertInstance[]

  @@index([eventType])
  @@index([enabled])
  @@map("alert_rules")
}

model AlertInstance {
  id              String   @id @default(cuid())
  alertRuleId     String
  relatedEntityId String?
  relatedEntityType String?
  
  status          String   @default("ACTIVE") // ACTIVE, ACKNOWLEDGED, RESOLVED
  severity        String   @default("MEDIUM")
  title           String
  message         String
  metadata        Json?
  
  acknowledgedBy  String?
  acknowledgedAt  DateTime?
  resolvedAt      DateTime?
  
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  alertRule       AlertRule @relation(fields: [alertRuleId], references: [id], onDelete: Cascade)

  @@index([alertRuleId])
  @@index([status])
  @@index([severity])
  @@index([relatedEntityId])
  @@map("alert_instances")
}

model NotificationPreference {
  id              String   @id @default(cuid())
  userId          String   @unique
  
  // Push notification settings
  enablePush      Boolean  @default(true)
  enableEmail     Boolean  @default(true)
  enableInApp     Boolean  @default(true)
  
  // Notification type preferences
  reconciliationAlerts Boolean @default(true)
  paymentAlerts   Boolean  @default(true)
  approvalAlerts  Boolean  @default(true)
  exceptionAlerts Boolean  @default(true)
  systemAlerts    Boolean  @default(true)
  
  // Timing preferences
  quietHoursStart String? // HH:mm format
  quietHoursEnd   String?
  
  // Digest settings
  enableDigest    Boolean  @default(false)
  digestFrequency String? // DAILY, WEEKLY, NEVER
  
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  user            User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("notification_preferences")
}

model NotificationLog {
  id              String   @id @default(cuid())
  notificationId  String?
  userId          String?
  type            String   // EMAIL_SENT, PUSH_SENT, IN_APP_CREATED, WEBHOOK_TRIGGERED
  
  status          String   // SUCCESS, FAILED, PENDING
  message         String?
  errorDetails    String?
  
  channel         String? // EMAIL, PUSH, WEBHOOK
  recipientEmail  String?
  
  metadata        Json?
  
  createdAt       DateTime @default(now())

  @@index([notificationId])
  @@index([userId])
  @@index([type])
  @@index([status])
  @@index([createdAt])
  @@map("notification_logs")
}

// ============================================================================
// ADVANCED REPORTING & CUSTOM REPORTS
// ============================================================================

model ReportTemplate {
  id              String   @id @default(cuid())
  name            String
  description     String?
  reportType      String   // aging, cashflow, dashboard
  
  // JSON arrays of column names to display
  columns         Json     @default("[]")
  
  // JSON object for custom filters (date range, customer, amount range, etc)
  filters         Json     @default("{}")
  
  createdById     String
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt
  
  createdBy       User     @relation(fields: [createdById], references: [id], onDelete: Cascade)
  
  @@index([createdById])
  @@index([reportType])
  @@index([createdAt])
  @@map("report_templates")
}

// ============================================================================
// isNotPaid: Boolean - Calculated as paidAmount < totalAmount
// isFullyPaid: Boolean - Calculated as paidAmount >= totalAmount
